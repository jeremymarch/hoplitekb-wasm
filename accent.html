<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="https://code.jquery.com/jquery-1.12.4.min.js"
integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ="
crossorigin="anonymous"></script>
<script>


    // Check for wasm support.
    if (!('WebAssembly' in window)) {
      alert('you need a browser with wasm support enabled :(');
    }

    // Loads a WebAssembly dynamic library, returns a promise.
    // imports is an optional imports object
/*
function fetchAndInstantiate(url, importObject) {
  return fetch(url).then(response =>
    response.arrayBuffer()
  ).then(bytes =>
    WebAssembly.instantiate(bytes, importObject)
  ).then(results =>
    results.instance
  );
}
    */
    function loadWebAssembly(filename, imports) {
      // Fetch the file and compile it
const importObject = {
  imports: {
    imported_func: function(arg) {
      console.log(arg);
    }
  }
};
      return fetch(filename)
        .then(response => response.arrayBuffer())
        .then(buffer => WebAssembly.compile(buffer))
        .then(module => {
          // Create the instance.
          return WebAssembly.instantiate(module);
        });
    }

function stripDiacriticsLocal(origChars) {
    
    var len = origChars.length;
    //add letter and any combining diacritics to the buffer as code points
    for (var i = 0; i < len; i++) {
        wasmBuffer[i] = origChars.codePointAt(i);
    }

    var stripMode = $("input:radio[name='stripMode']:checked").val();

    len = stripDiacritics2(wasmBuffer.byteOffset, len, stripMode);
    //transform the returned code points back to a string
    var newLetter = "";
    for (var i = 0; i < len; i++) {
        newLetter += String.fromCodePoint(wasmBuffer[i]);
    }
    return newLetter;
}

var wasmBuffer;
var wasmBuffer1;
var wasmBuffer2;
var accentSyllableWASM;
var stripDiacritics2;
var compareWASM;
var convertWASM;

loadWebAssembly('hoplitekb.wasm')
  .then(instance => {
    var exports = instance.exports;
    accentSyllableWASM = exports.accentSyllable2;
    stripDiacritics2 = exports.stripDiacritics;
    convertWASM = exports.convertString;
    compareWASM = exports.compare;
    var memory = exports.memory;

    wasmBuffer = new Uint16Array(memory.buffer, 0, 1024);
    wasmBuffer1 = new Uint16Array(memory.buffer, 1024, 1024);
    wasmBuffer2 = new Uint16Array(memory.buffer, 2048, 1024);
    
    // now we are ready, set up the button so the user can run the code
    var button = document.getElementById('compareButton');
    button.value = 'Call a method in the WebAssembly module';
    button.addEventListener('click', compareLocal);
    
  }
);

function convertLocal()
{
    var a = $("#inp").val();
    var bufferCapacity = 1024;
    for (var i = 0; i < a.length && i < bufferCapacity; i++) {
        wasmBuffer1[i] = a.codePointAt(i);
    }

    var unicodeMode = $("input:radio[name='convertMode']:checked").val();

    var newStringLen = convertWASM(wasmBuffer1.byteOffset, a.length, wasmBuffer2.byteOffset, bufferCapacity, parseInt(unicodeMode));

    var newStr = "";
    for (var i = 0; i < newStringLen; i++) {
        newStr += String.fromCodePoint(wasmBuffer2[i]);
    }

    $("#conv1").val(newStr);
    $("#conv2").val(strToCodePoints(newStr));

}

function compareLocal()
{
    var a = $("#comp1").val();
    var b = $("#comp2").val();
    /*
    var encoder = new TextEncoder("utf-16");
    var aE = encoder.encode(a);
    var bE = encoder.encode(b);
    wasmBuffer1.set(aE);
    wasmBuffer2.set(bE);
    */
    for (var i = 0; i < a.length; i++) {
        wasmBuffer1[i] = a.codePointAt(i);
    }
    for (var i = 0; i < b.length; i++) {
        wasmBuffer2[i] = b.codePointAt(i);
    }
    var x = compareWASM(wasmBuffer1.byteOffset, a.length, wasmBuffer2.byteOffset, b.length, 0);
    /*
    var decoder = new TextDecoder("utf-16");
    var a2 = decoder.decode(wasmBuffer1.slice(aE.length));
    var b2 = decoder.decode(wasmBuffer2.slice(bE.length));
    */
    console.log("compare: " + a + ", " + b + ": " + x);
    $("#compareResult").html(x);
}

function test()
{
    var a = $("#inp").val();

    $("#inp").val( stripDiacriticsLocal(a) );
}

function strToCodePoints(str)
{
    var a = "";
    for (var i = 0; i < str.length; i++) {
        a += str.codePointAt(i).toString(16).padStart(4,"0").toUpperCase() + " ";
    }
    return a.trim();
}

function start() {
	$(".gkinput").keypress(handleKey);

    $("#inp").keyup(function(){
        
        $("#codes").val( strToCodePoints(this.value) );

        var stripped = stripDiacriticsLocal(this.value);
        $("#codes2").val(stripped);
        convertLocal();

        $("#codes3").val( strToCodePoints(stripped) );
    }); 
}

var la = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
var gr = ["α","β","ψ","δ","ε","φ","γ","η","ι","ξ","κ","λ","μ","ν","ο","π","ϝ","ρ","σ","τ","θ","ω","ς","χ","υ","ζ","Α","Β","Ψ","Δ","Ε","Φ","Γ","Η","Ι","Ξ","Κ","Λ","Μ","Ν","Ο","Π","Ϝ","Ρ","Σ","Τ","Θ","Ω","Σ","Χ","Υ","Ζ"];
var forceLowercase = true;
function transliterate(char)
{
    var f = $("input:radio[name='lowerCaseMode']:checked").val();

    var theChar = (f != 0) ? char.toLowerCase() : char;
    var idx = la.indexOf(theChar);
    if (idx > -1) {
        return gr[idx];
    }
    else {
        return char;
    }
}

function accentSyllable(origChars, key) {
    var len = origChars.length;
    //add letter and any combining diacritics to the buffer as code points
    for (var i = 0; i < len; i++) {
        wasmBuffer[i] = origChars.codePointAt(i);
    }

    len = accentSyllableWASM(wasmBuffer.byteOffset, len, key, 1, parseInt(unicodeMode) );

    //transform the returned code points back to a string
    var newLetter = "";
    for (var i = 0; i < len; i++) {
        newLetter += String.fromCodePoint(wasmBuffer[i]);
    }

    //let win1251decoder = new TextDecoder('utf-16le');
    return [len, newLetter];
}
var unicodeMode = 0;
function handleKey(evt) {
    var val = this.value;
    evt = evt || window.event;

    var charCode = typeof(evt.which) == "number" ? evt.which : evt.keyCode;

    if (charCode && charCode > 64 && charCode < 123) //letter
    {
        var start = this.selectionStart;
        var end = this.selectionEnd;
        var key = String.fromCharCode(charCode);

        var mappedChar = transliterate(key);
        var charsToReplace = 0;
        this.value = val.slice(0, start - charsToReplace) + mappedChar + val.slice(end);
        // Move the caret
        this.selectionStart = this.selectionEnd = start + 1 - charsToReplace;
        return false;
    }
    else if (charCode && charCode > /*47 blocking underdot here*/47 && charCode < 58) { //number: 0-9 are 48-57
        var key = String.fromCharCode(charCode);
        var hckey = 0;
        switch( parseInt(key) ) {
            case 1:
                hckey = 5; //rough
                break;
            case 2:
                hckey = 6; //smooth
                break;
            case 3:
                hckey = 1; //acute
                break;
            case 4:
                hckey = 3; //grave
                break;
            case 5:
                hckey = 2; //circumflex
                break;
            case 6:
                hckey = 4; //macron
                break;
            case 7:
                hckey = 10; //breve
                break;
            case 8:
                hckey = 7; //iota subscript
                break;
            case 9:
                hckey = 9; //diaeresis
                break;
            case 0:
                hckey = 11; //underdot
                break;
        }
        var start, end;
        if (typeof(this.selectionStart) == "number" && typeof(this.selectionEnd) == "number") {
            // Non-IE browsers and IE 9+
            start = this.selectionStart;
            end = this.selectionEnd;

            var combining = [0x0300, 0x0301, 0x0304, 0x0306, 0x0308, 0x0313, 0x0314, 0x0323, 0x0342, 0x0345];
            var off = 1;
            for (var i = start; i > -1; i--)
            {
                if (combining.indexOf(val.codePointAt(i - 1)) > -1) {
                    off++;
                }
                else {
                    break;
                }
            }

            unicodeMode = $("input:radio[name='unicodeMode']:checked").val();

            var ret = accentSyllable(val.slice(start - off, start), hckey.toString());
            var newLetter = ret[1];
            var charsToReplace = start - (start - off);
 
            if (ret[0] > 0 && newLetter != "")
            {
                //update the input/textarea
                this.value = val.slice(0, start - charsToReplace) + newLetter + val.slice(end);
                // Move the caret
                this.selectionStart = this.selectionEnd = (start - charsToReplace) + ret[0];
            }

        } 
        return false;
    }
    return true;
}

</script>
<style>
@font-face {
  font-family: 'WebNewAthenaUnicode';
  src: url('/newathu5.ttf') format('truetype');
}
body { 
    margin:0px;padding:0px;background-color:#BBB;color:black;font-family: helvetica,arial;
}
#compareResult { color:black; }
@media (prefers-color-scheme: dark) {
    body {
        background-color:#202124;
        color:white;
    }
    #compareResult { color:white; }
}

#container {
    margin:10px auto;width:90%;
}
.gkinput, .gkinputnontyping {
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
.gkinputcodes {   
    font-family: helvetica,arial;
}
.gkinput, .gkinputcodes, .gkinputnontyping {
    -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
    -moz-box-sizing: border-box;    /* Firefox, other Gecko */
    box-sizing: border-box;         /* Opera/IE 8+ */
    width: 100%;
    padding: 0px 0.5em;
    height: 40px;
    font-size: 20pt;
    border-radius: 6px;
    border: 2px solid #666;
    margin:6px 0px;

}

.gkinput:focus, .gkinputcodes:focus, .gkinputnontyping:focus{
    outline:2px solid blue;
}
</style>
</head>
<body onload="start()">
    <div id="container">
	<input type="radio" checked name="unicodeMode" value="0">Precomposed
    <input type="radio" name="unicodeMode" value="1">Precomposed with PUA
    <input type="radio" name="unicodeMode" value="2">Combining-only

    | <input type="radio" name="lowerCaseMode" value="1">Force Lowercase
    <input type="radio" checked name="lowerCaseMode" value="0">Allow Uppercase

	<input class="gkinput" type="text" id="inp"/>
    <input class="gkinputcodes" type="text" id="codes"/>
    <br><br>
    <br>Strip diacritics: <input type="radio" checked name="stripMode" value="1">strip non-Greek
    <input type="radio" name="stripMode" value="0">keep non-Greek
    <input class="gkinputnontyping" type="text" id="codes2"/>
    <input class="gkinputcodes" type="text" id="codes3"/>
    <br><br>
    <br>Convert:  
    <input type="radio" name="convertMode" value="0">Precomposed
    <input type="radio" name="convertMode" value="1">Precomposed with PUA
    <input type="radio" checked name="convertMode" value="2">Combining-only<br>
    <input class="gkinputnontyping" type="text" id="conv1"/>
    <input class="gkinputcodes" type="text" id="conv2"/>

    <br><br><br>
    <button id="compareButton">compare</button> <span id="compareResult"></span><br>
    <input class="gkinput" type="text" id="comp1"/><br>
    <input class="gkinput" type="text" id="comp2"/><br>
    </div>
</body>
</html>
